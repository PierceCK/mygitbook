# 数据流重定向

#### 标准输出 ( STDOUT ) [ standard output ] 与 标准错误输出 ( STDERR ) [ standard error output ]

- 标准输出: 指的是命令执行所返回的正确信息
  标准错误输出: 可以理解为命令执行失败后, 所返回的错误信息

- 数据流重定向可以将stdout与stderr分别传送到其他的文件或设备, 而分别传送所用的特殊字符则如下所示:

  - 标准输入(stdin): 代码为0, 使用 < 或 <<

  - 标准输出(stdout): 代码为1, 使用 > 或 >>

  - 标准错误输出(stderr): 代码为2, 使用 2> 或 2>>

| 数据流重定向 | 说明                                                         |
| ------------ | :----------------------------------------------------------- |
| <            | 将原本需要由键盘输入的数据, 改由文件内容来替换               |
| <<           | 代表 [ 结束的输入字符 ] <br />如: 我要用cat直接将输入的信息输出到catfile中, 且当由键盘输入eof时, 该次输入就结束. cat > catfile << "eof" |
| 1>           | 以覆盖的方法将 [ 正确的数据 ] 输出到指定的文件或设备上       |
| 1>>          | 以累加的方法将 [ 正确的数据 ] 输出到指定的文件或设备上       |
| 2>           | 以覆盖的方法将 [ 错误的数据 ] 输出到指定的文件或设备上       |
| 2>>          | 以累加的方法将 [ 错误的数据 ] 输出到指定的文件或设备上       |
| 2>&1         | 把标准错误输出重定向到标准输出                               |
| 1>&2         | 把标准输出重定向到标准错误输出                               |
| &> filename  | 把标准输出和标准错误输出都重定向到文件filename中             |



#### 命令执行的判断根据: ; 、&&、||

- cmd( 不考虑命令相关性的连续命令执行 )

  - 在命令与命令中间利用分号 ( **;** ) 来隔开, 这样一来, 分号前的命令执行完后就会立刻接着执行后面的命令.

- $？ ( 命令返回值 ) 与 && 与 ||

  - 若前一个命令执行的结果为正确, 在Linux下面会返回一个 $？=0 的值


| 命令执行情况   | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| cmd1 && cmd2   | 若 cmd1 执行完毕且正确执行( $?=0 ), 则开始执行 cmd2<br />若 cmd1 执行完毕且为错误( $?≠0 ), 则 cmd2 不执行 |
| cmd1 丨丨 cmd2 | 若 cmd1 执行完毕且正确执行( $?=0 ), 则 cmd2 不执行<br />若 cmd1 执行完毕且为错误( $?≠0 ), 则开始执行 cmd2 |





