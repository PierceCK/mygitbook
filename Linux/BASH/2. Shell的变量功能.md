# Shell的变量功能

#### 什么是变量？

- 变量就是以一组文字或符号等, 来替换一些设置或是一串保留的数据.
- 变量主要有 **环境变量** 和 **自定义变量** , 或成为 全局变量 与 局部变量.
  - 环境变量通常以大写字符来表示
  - 基本上, 在Linux默认的情况中, 使用{大写的字母}来设置的变量一般为系统内定需要的变量
  - 环境变量与自定义变量的差异在于: 该变量是否会被子进程所继续引用
    - 子进程仅会继承父进程的环境变量, 不会继承父进程的自定义变量



#### 变量的使用与设置: echo、变量设置规则、unset

- 变量的使用: echo
  - 变量在被使用时, 变量名称前面必须要加上**美元符号($)** 或是 **${变量}**.
    - 如 echo $PATH 或 echo ${PATH}
    - 如 cd $PATH 或 cd ${PATH}
  
- 变量设置规则

  - 在bash当中, 当一个变量名称尚未被设置时, 默认的内容是[空]
  - 变量与变量内容以一个等号(=)来连接
  - 等号两边不能直接接空格
  - 变量名称只能是英文字母与数字, 但是开头字符不能是数字
  - 变量内容若有空格可使用双引号(")或单引号(")将变量内容结合起来, 但:
    - 双引号内的特殊字符如$等, 可以保有原本的特性
    - 单引号内的特殊字符则仅为一般字符(纯文本)
  - 可用转义符(\\)将特殊字符变成一般字符
  - 在一串命令的执行中, 还需要**借由其他额外的命令所提供的信息时(即获得某命令的返回值)**, 可以使用反单引号[ \`命令\` ] 或 [ **$(命令)** ].
  - 若该命令为**扩增变量内容**时, 则可用 [ "$变量" ] 或 [ **${变量}** ] 累加内容, 如: PATH="$PATH":/home/bin 或 PATH=${PATH}:/home/bin
  - 通常大写字符为系统默认变量, 自行设置变量可以使用小写字符

- 取消变量: unset

  - 取消变量的方法为使用 unset , 即使用[ unset 变量名称 ], 如 unset myname 为取消myname这个变量的设置

  

#### 环境变量的功能

- env : 观察环境变量与常见环境变量说明

  - 使用env命令可以列出来所有的环境变量

| 环境变量 |                                                              |
| -------- | ------------------------------------------------------------ |
| HOME     | 代表用户的根目录                                             |
| SHELL    | 目前这个环境使用的SHELL                                      |
| HISTIZE  | 命令历史记录的条数的最大值                                   |
| MAIL     | 使用mail命令收信时, 系统会去读取的邮箱文件                   |
| PATH     | 执行文件查找的目录, 目录与目录中间以冒号( : )分隔            |
| LANG     | 语系数据, 如我们中文编码通常是zh_CN.UTF-8                    |
| RANDOM   | 关于随机数的变量, 使用这个变量系统会主动地随机地取出一个0~32767的数值 |



- set : 观察所有变量(含环境变量与自定义变量)

  - 使用set命令可以列出来所有的变量

| PS1: 命令提示字符的设置(PS1不是环境变量) |                                                              |
| ---------------------------------------- | ------------------------------------------------------------ |
| \d                                       | 可显示出[ 星期 月 日 ]的日期格式                             |
| \H                                       | 完整的主机名                                                 |
| \h                                       | 仅取主机名在第一个小数点之前的名字                           |
| \t                                       | 显示时间, 为24小时格式的 [ HH:MM:SS ]                        |
| \T                                       | 显示时间, 为12小时格式的 [ HH:MM:SS ]                        |
| \A                                       | 显示时间, 为24小时格式的 [ HH:MM ]                           |
| \@                                       | 显示时间, 为12小时格式的 [ am/pm ]                           |
| \u                                       | 目前用户的账号名称                                           |
| \v                                       | BASH的版本信息                                               |
| \w                                       | 完整的工作目录名称, 由根目录写起的目录名称, 但根目录会以~替换 |
| \W                                       | 利用basename函数取得工作目录名称, 所以仅会列出最后一个目录名 |
| \\#                                      | 执行的第几个命令                                             |
| \\$                                      | 提示字符, 如果是root时, 提示字符为 #, 否则就是$              |



- 特殊变量

| 特殊变量 |                                                              |
| -------- | ------------------------------------------------------------ |
| $        | 目前这个shell的进程号                                        |
| ？       | 上一个执行的命令所返回的值. 一般来说, 如果成功的执行某一个命令, 则会返回一个0值 |



- export : 自定义变量转成环境变量

  - export 变量名称, 可以将变量转换成环境变量
  - 直接使用export命令时, 会把所有的环境变量显示出来



#### locale : 影响显示结果的语系变量

- locale -a : 查询Linux系统支持的语系编码
- locale : 自定义语系编码
  - 如果你设置了LANG或LC_ALL时, 但其他的语系变量没有设置, 则其他的语系变量就会被这两个变量所替换



#### 变量的有效范围

- 环境变量 = 全局变量
- 自定义变量 = 局部变量
- 为什么环境变量的数据可以被子进程引用？这是因为内存配置的关系, 理论上是这样的:
  - 当启动一个shell时, 操作系统会分配一个内存区域给shell使用, 此内存中的变量可以让子进程使用;
  - 若在父进程利用export功能, 可以让自定义变量的内容写到上述的内存区域当中(环境变量);
  - 当加载另一个shell时(即启动子进程, 离开原本的父进程), 子shell可以将父shell的环境变量所在的内存区域导入自己的环境变量区块当中.



#### 变量键盘读取、数组与声明: read、array、declare

- read : 读取来自键盘输入的变量 (相当于输入)

  - read [-pt] variable

| 选项与参数 | 描述                             |
| ---------- | -------------------------------- |
| 什么都不加 | 会主动出现一个空白行等待你的输入 |
| -p         | 后面可以接提示字符               |
| -t         | 后面可以接等待的秒数             |



- declare, typeset : 声明变量的类型

  - declare或typeset是一样的功能

  - declare [-aixr] variable

    - 变量类型默认为字符串

    - bash环境中的数值运算, 默认最多仅能到达整数形态, 所以1/3结果为0

    - 数组变量类型

      - 数组的设置方式是: variable[index]=content

        ```
        declare -a var
        var[1]="1"
        var[2]="This is 2"
        var[3]="3"
        ```

| 选项与参数 | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| -a         | 将后面名为variable的变量定义为数组类型                       |
| -i         | 将后面名为variable的变量定义为整数类型                       |
| -x         | 用于与export一样, 就是将后面的variable变成环境变量           |
| -r         | 将变量设置为readonly类型, 该变了不可被更改内容, 也不能unset. 只能通过注销再登录的方式恢复该变量的类型. |



#### 与文件系统与程序的限制关系: ulimit

- bash是可以限制用户的某些系统资源的, 包括可以开启的文件数量, 可以使用的CPU时间, 可以使用的内存总量等

- ulimit [-SHacdfltu] [配额]

| 选项与参数 | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| -H         | hard limit, 严格的设置, 必定不能超过这个设置的数值           |
| -S         | soft limit, 警告的设置, 可以超过这个设置值, 但是若超过则有警告信息<br />在设置上, 通常soft会比hard小 |
| -a         | 后面不接任何选项与参数, 可列出所有的限制额度                 |
| -c         | 限制每个内核文件的最大容量<br />当某写程序发生错误时, 系统可能会将该程序在内存中的信息写成文件(除错用), 这种文件就被称为内核文件. |
| -f         | 此shell可以建立的最大文件容量(一般可能设置为2GB)单位为Kbytes |
| -d         | 程序可使用的最大段内存容量                                   |
| -l         | 可用于锁定的内存量                                           |
| -t         | 可使用的最大CPU时间                                          |
| -u         | 单一使用者可以使用的最大进程数量                             |



#### 变量内容的删除、取代与替换

- 变量内容的删除与替换

| 变量设置方式                                              | 说明                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| ${变量#关键词}<br />${变量##关键词}                       | 若变量内容**从头开始**的数据符合 [ 关键词 ] , 则将符合的最短数据删除<br />若变量内容**从头开始**的数据符合 [ 关键词 ] , 则将符合的最长数据删除 |
| ${变量%关键词}<br />${变量%%关键词}                       | 若变量内容**从尾向前**的数据符合 [ 关键词 ] , 则将符合的最短数据删除<br />若变量内容**从尾向前**的数据符合 [ 关键词 ] , 则将符合的最长数据删除 |
| ${变量/旧字符串/新字符串}<br />${变量//旧字符串/新字符串} | 若变量内容符号 [ 旧字符串 ] 则 [ 第一个旧字符串会被新字符串替换 ]<br />若变量内容符号 [ 旧字符串 ] 则 [ 全部的旧字符串会被新字符串替换 ] |



- 变量的测试与内容替换

| 变量设置方式     | str没有设置                 | str为空字符串               | str已设置非为空字符串 |
| ---------------- | --------------------------- | --------------------------- | --------------------- |
| var=${str-expr}  | var=expr                    | var=                        | var=$str              |
| var=${str:-expr} | var=expr                    | var=expr                    | var=$str              |
| var=${str+expr}  | var=                        | var=expr                    | var=expr              |
| var=${str:+expr} | var=                        | var=                        | var=expr              |
| var=${str=expr}  | str=expr<br />var=expr      | str不变<br />var=           | str不变<br />var=$str |
| var=${str:=expr} | str=expr<br />var=expr      | str=expr<br />var=expr      | str不变<br />var=$str |
| var=${str?expr}  | expr输出至 stderr(标准错误) | var=                        | var=$str              |
| var=${str:?expr} | expr输出至 stderr(标准错误) | expr输出至 stderr(标准错误) | var=$str              |

