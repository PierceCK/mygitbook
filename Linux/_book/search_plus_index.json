{"./":{"url":"./","title":"前言","keywords":"","body":"前言 Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 04:09:58 "},"vi程序编辑器/":{"url":"vi程序编辑器/","title":"vi程序编辑器","keywords":"","body":"Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-12 04:25:02 "},"vi程序编辑器/1. vi的使用.html":{"url":"vi程序编辑器/1. vi的使用.html","title":"vi的使用","keywords":"","body":"vi的使用 一般命令模式可用的功能按键说明 移动光标的方法 h或左箭头键(←) 光标向左移动一个字符 j或下箭头键(↓) 光标向下移动一个字符 k或上箭头键(↑) 光标向上移动一个字符 l或右箭头键(→) 光标向右移动一个字符 [Ctrl] + [f] 屏幕[向下]移动一页, 相当于[Page Down]按键(常用) [Ctrl] + [b] 屏幕[向上]移动一页, 相当于[Page Up]按键(常用) [Ctrl] + [d] 屏幕[向下]移动半页 [Ctrl] + [u] 屏幕[向上]移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n(数字)[空格键] 光标向右移动这一行的n个字符,例如,20[空格键]则光标会向后移动20个字符的距离 0(数字0)或功能键[Home] 移动到这一行的最前面字符处(常用) $或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个文件的最后一行(常用) n(数字)G 移动到这个文件的第n行, 例如20G则会移动到这个文件的第20行 gg 移动到这个文件的第一行, 相当于1G(常用) n(数字)[Enter] 光标向下移动n行(常用) 查找与替换 /word 向光标之下寻找一个名称为word的字符串. 例如要在文件内查找vbrid这个字符串, 就输入/vbrid即可.(常用) ?word 向光标之上寻找一个名称为word的字符串 n n表示[重复前一个查找的操作]. 例如, 如果刚刚我们执行/vbrid去向下查找vbird这个字符串, 则按下n后, 会向下继续查找下一个名称为vbird的字符串. N 与n正好相反, 表示[反向进行前一个查找操作]. 例如/vbrid后, 按下N则表示向上查找vbrid. :n1(数字),n2(数字)s/word1/word2/g 在第你n1行与n2行之间寻找word1这个字符串, 并将该字符串替换为word2, 举例来说, 在100到200行之间查找vbrid并替换为VBRID则: \":100,200s/vbrid/VBRID/g\"(常用) :1,$s/word1/word2/g 从第一行到最后一行寻找word1字符串, 并将该字符串替换为word2(常用) :1,$s/word1/word2/gc 从第一行到最后一行寻找word1字符串, 并将该字符串替换为word2, 且在替换前提示字符给用户确认是否需要替换(常用) 删除、复制与粘贴 x与X 在一行当中, x为向后删除一个字符(相当于[del]按键), X为向前删除一个字符(相当于[Backspace]即退格键).(常用) n(数字)x 连续向后删除n个字符. 举例来说, 连续删除10个字符, 即[10x] dd 删除(剪切)光标所在的那一整行.(常用) n(数字)dd 删除(剪切)光标所在的向下n行, 例如20dd则是删除(剪切)20行.(常用) d1G 删除(剪切)光标所在行到第一行的所有数据. dG 删除(剪切)光标所在行到最后一行的所有数据. d$ 删除(剪切)光标所在处到该行的最后一个字符. d0(数字0) 删除(剪切)光标所在处到改行的第一个字符. yy 复制光标所在的那一行.(常用) n(数字)yy 复制光标所在的向下n行, 例如20yy则是复制20行.(常用) y1G 复制光标所在行到第一行的所有数据. yG 复制光标所在行到最后一行的所有数据. y0 复制光标所在处到该行行首的所有数据. y$ 复制光标所在处到该行行尾的所有数据. p与P p为将已复制的数据在光标下一行粘贴. P则为粘贴在光标的上一行. J 将光标所在行与下一行的数据结合成一行. c 重复删除多个数据, 举例来说, 向下删除10行, 即[10cj]. u 恢复前一个操作.(常用) [Ctrl] + r 重做上一个操作.(常用) .(小数点) 重复前一个操作.(常用) 一般命令模式切换到编辑模式的可用的按键说明 进入插入或替换的编辑模式 i与I 进入插入模式: i为[从目前光标所在处插入], I为[在目前所在行的第一个非空格符处开始插入].(常用) a与A 进入插入模式: a为[从目前光标所在的下一个字符处开始插入], A为[从光标所在行的最后一个字符处开始插入].(常用) o与O 进入插入模式: o为[在目前光标所在的下一行处插入新的一行], O为[在目前光标所在处的上一行插入新的一行].(常用) r与R 进入替换模式: r只会替换光标所在的那个字符一次; R会一直替换光标所在的字符, 直到按下Esc为止.(常用) [Esc] 退出编辑模式, 回到一般命令模式中. 一般命令模式切换到命令行模式的可用按键说明 命令行模式的保存、退出等命令 :w 将编辑的数据写入到硬盘文件中.(常用) :w! 若文件属性为[只读]时, 强制写入该文件. 不过, 到底能不能写入, 还是跟你对该文件的文件权限有关. :q 退出vi.(常用) :q! 若曾修改过文件, 又不想保存, 使用!为强制退出不保存. :wq 保存后退出, 若为:wq!则为强制保存后退出.(常用) ZZ 若文件没有修改, 则不保存退出, 若文件已经被修改, 则保存后退出 :w [filename] 将编辑的数据保存成另一个文件(类似另存新文件). :r [filename] 在编辑的数据中, 读入另一个文件的数据, 亦即将[filename]这个文件内容加到光标所在行后面. :n1(数字),n2(数字) w [filename] 将n1行到n2行的内容保存为filename这个文件. :! [command] 暂时退出vi到命令行模式下执行command的显示结果. 例如, [:! ls /home]即可在vi当中查看/home下面以ls输出的文件信息 :set nu 显示行号, 设置之后, 会在每一行的前缀显示该行的行号. :set nonu 与set nu相反, 为取消行号. Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 14:46:38 "},"vi程序编辑器/2. vim的额外功能.html":{"url":"vi程序编辑器/2. vim的额外功能.html","title":"vim的额外功能","keywords":"","body":"vim的额外功能 可视区块(Visual Block) 可视区块的按键意义 v 字符选择, 会将光标经过的地方反白选择(类似于多选) V 行选择, 会将光标经过的行反白选择 [Ctrl] + v 可视区块, 可以用矩形的方式选择数据 y 将反白的地方复制起来 d 将反白的地方删除掉 p 将刚刚复制的区块, 在光标所在处粘贴 多文件编辑 可以使用vim命令同时打开多个文件, 例如, [vim hosts /etc/hosts]命令来使用一个vim打开两个文件. 多文件编辑的按键 :n 编辑下一个文件 :N 编辑上一个文件 :files 列出目前这个vim开启的所有文件 多窗口功能 多窗口情况下的按键功能 :sp [filename] 打开一个新窗口, 如果有加[filename], 表示在新窗口创建一个新文件, 否则表示两个窗口为同一个文件内容(同步显示). [Ctrl] + w + j或↓ 光标移动到下面的窗口. 按键的按法是: 先按下[Ctrl]不放, 再按下w后放开所有的按键, 之后再按下j或↓. [Ctrl] + w + k或↑ 光标移动到上面的窗口. 同上 [Ctrl] + w + q 关闭所在的窗口, 可以输入:q退出, 也可以按下[Ctrl] + w + q退出, 此外还可以输入\":close\"退出. vim关键词补全功能 组合键 补齐的内容 [Ctrl] + x -> [Ctrl] + n 通过目前正在编辑的这个[文件的内容文件]作为关键词, 予以补充 [Ctrl] + x -> [Ctrl] + f 以当前目录内的[文件名]作为关键词, 予以补充 [Ctrl] + x -> [Ctrl] + o 以扩展名作为语法补充, 以vim内置的关键词, 予以补充 vim环境设置与记录 整体vim的设置值一般是放置在/etc/vimrc这个文件夹中, 不过, 不建议你修改它, 你可以修改~/.vimrc这个文件( 默认不存在, 需要你自行手动建立 ), 将你所希望的设置值写入. 注意, 这个文件中的双引号(\")是注释符号. vim的环境设置参数 :set nu:set nonu 设置与取消行号 :set hlsearch:set nohlsearch hlsearch就是high light search(高亮度查找), 这个就是设置是否将查找的字符串反白的设置值, 默认是hlsearch. :set autoindent:set noautoindent 是否自动缩进?autoindent就是自动缩进. :set backup 是否自动保存备份文件？一般是nobackup的, 如果设置backup的话, 那么当你修改任何一个文件时, 则源文件会被另存为一个文件名为filename~的文件. 举例来说, 我们编辑hosts, 设置:set backup, 那么当修改hosts时, 在同目录下, 就会产生hosts~文件名的文件, 记录原始的hosts文件内容. :set ruler 设置是否显示在右下角的一些状态栏说明. :set showmode 是否要显示--INSERT--之类的字眼在左下角的状态栏 :set backspace=(0,1,2) 一般来说, 如果我们按下i进入编辑模式后, 可以利用退格键来删除任意字符. 但是, 某些Linux发行版则不许如此. 此时, 我们就可以通过backspace来设置, 当backspace为2时, 就是可以删除任意值; 0或1时, 仅可删除刚刚输入的字符, 而无法删除原本就已经存在的文字. :set all 显示目前所有的环境参数设置值. :set 显示与系统默认值不同的设置参数, 一般来说就是你有自行变动过的设置参数. :syntax on:syntax off 是否依据程序相关语法显示不同颜色. 举例来说, 在编辑一个纯文本文件时, 如果开头是以#开始, 那么该行就会变成蓝色. 如果你懂得写程序, 那么这个:syntax on还会主动的帮你除错.但是, 如果你仅是编写纯文本文件, 要避免颜色对你的屏幕产生的干扰, 则可以取消这个设置. :set bg=dark:set bg=light 可用以显示不同的颜色色调, 默认是[light]. Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 22:39:29 "},"BASH/":{"url":"BASH/","title":"认识与学习BASH","keywords":"","body":"Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-26 17:29:23 "},"BASH/1. 认识BASH这个Shell.html":{"url":"BASH/1. 认识BASH这个Shell.html","title":"认识BASH这个Shell","keywords":"","body":"认识BASH这个Shell 硬件、内核与Shell 我们必须要通过Shell将我们输入的命令与(kernel)沟通, 好让内核可以控制硬件来正确无误地工作. 我们发现应用程序在操作系统图例的最外层, 就如同鸡蛋的外壳一样, 因此这个东西也被称为壳程序(Shell). 也就是说,, 只要能够操作应用程序的软件都能够被称为 壳程序. 狭义的Shell: 值得是命令行方面的软件, 就如bash. 广义的Shell: 则包括图形用户界面模式的软件, 因为图形用户界面模式其实也能够操作各种应用程序来调用内核工作. 为何要学命令行模式的Shell？ 几乎各家Linux发行版使用的bash都是一样的. 联机时命令行模式的传输速度一定比较快, 而且不容易出现掉线或是信息外流的问题. 如何想要将主机管理的好, 那么良好的shell程序编写是一定需要的. 系统的合法shell与 /etc/shells功能 Linux使用的shell版本被称为 Bourne Again SHell(简称bash) 这个shell是Bourne shell(sh)的增强版本 Linux可以使用的shell版本放在 /etc/shells 这个文件里, 至少就有下面几个可用的shells /bin/sh (已经被 /bin/bash 所替换) /bin/bash (Linux默认的shell) /bin/tcsh (整合C Shell, 提供更多的功能) /bin/csh (已经被 /bin/tcsh 所替换) 为什么我们系统上合法的shell要写入 /etc/shells 这个文件？ 因为系统某些服务在运行过程中, 会去检查用户能够使用的shells, 而这些shell的查询就是借由 /etc/shells 这个文件. 用户什么时候可以取得shell来工作？还有, 我这个用户默认会取得哪一个shell？ 当用户登录时, 系统就会给用户一个shell让用户来工作, 而这个登录取得的shell就记录在 /etc/passwd 这个文件内. 用户默认取得的shell记录于 etc/passwd 的最后一个字段. ​ Bash shell 的功能 历史命令 bash能记录使用过的命令, 在命令行使用↑↓键就可以找到前后一个输入的命令. ~/.bash_history记录的是 前一次登录 以前所执行过的命令, 这一次登录 所执行的命令都被缓存在内存中. 当用户成功的注销系统后, 这一次登录所执行的命令才会被记录到.bash_history当中. 默认的命令记录条目可以到达1000个 命令与文件补全功能( [Tab] 按键 ) [Tab] 接在一串命令的 第一个字 的后面, 则为 命令补全 [Tab] 接在一串命令的 第二个字 的后面, 则为 文件补齐 命令别名设置功能 ( alias ) 命令行输入 alias 就可以知道目前的命令别名有哪些 直接执行命令来设置别名, 如: alias lm='ls -al', 即输入\"lm\" 等于 输入\"ls -al\". 任务管理、前台、后台控制 程序化脚本 通配符 type : 查询命令是否为Bash shell的内置命令 type [-tpa] name 选项与参数 说明 不加任何选项与参数时, type会显示出name是外部命令还是bash内置命令 -t type将name以下面这些字眼显示出它的意义:file : 表示为外部命令alias : 表示该命令为命令别名所设置的名称builtin : 表示该命令为bash内置的命令功能 -p 只有name为外部命令时, 才会显示完整文件名 -a 会从PATH变量定义的路径中, 将所有含name的命令都列出来, 包括alias 命令执行与快速编辑按钮 如果命令串太长想多行输入, 可以将 [Enter] 转义后, 换行继续输入 [ \\[Enter] ], 使用反斜杠(\\)转义[Enter]这个按键, 让[Enter]不再具有开始执行的功能 注意: [Enter]是紧接着反斜杠(\\)的, 两者中间没有其他字符 因为 \\ 仅转移紧接着的下一个字符 顺利转义[Enter]后, 下一行最前面会 自动 出现 > 的符号, 你就可以继续输入命令了. 快速编辑按钮 组合键 功能与示范 [Ctrl] + u[Ctrl] + k 从光标处向前删除命令串从光标处向后删除命令串 [Ctrl] + a[Ctrl] + e 让光标移动到整个命令串的最前面让光标移动到整个命令串的最后面 Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-19 13:57:41 "},"BASH/2. Shell的变量功能.html":{"url":"BASH/2. Shell的变量功能.html","title":"Shell的变量功能","keywords":"","body":"Shell的变量功能 什么是变量？ 变量就是以一组文字或符号等, 来替换一些设置或是一串保留的数据. 变量主要有 环境变量 和 自定义变量 , 或成为 全局变量 与 局部变量. 环境变量通常以大写字符来表示 基本上, 在Linux默认的情况中, 使用{大写的字母}来设置的变量一般为系统内定需要的变量 环境变量与自定义变量的差异在于: 该变量是否会被子进程所继续引用 子进程仅会继承父进程的环境变量, 不会继承父进程的自定义变量 变量的使用与设置: echo、变量设置规则、unset 变量的使用: echo 变量在被使用时, 变量名称前面必须要加上美元符号($) 或是 ${变量}. 如 echo $PATH 或 echo ${PATH} 如 cd $PATH 或 cd ${PATH} 变量设置规则 在bash当中, 当一个变量名称尚未被设置时, 默认的内容是[空] 变量与变量内容以一个等号(=)来连接 等号两边不能直接接空格 变量名称只能是英文字母与数字, 但是开头字符不能是数字 变量内容若有空格可使用双引号(\")或单引号(\")将变量内容结合起来, 但: 双引号内的特殊字符如$等, 可以保有原本的特性 单引号内的特殊字符则仅为一般字符(纯文本) 可用转义符(\\)将特殊字符变成一般字符 在一串命令的执行中, 还需要借由其他额外的命令所提供的信息时(即获得某命令的返回值), 可以使用反单引号[ `命令` ] 或 [ $(命令) ]. 若该命令为扩增变量内容时, 则可用 [ \"$变量\" ] 或 [ ${变量} ] 累加内容, 如: PATH=\"$PATH\":/home/bin 或 PATH=${PATH}:/home/bin 通常大写字符为系统默认变量, 自行设置变量可以使用小写字符 取消变量: unset 取消变量的方法为使用 unset , 即使用[ unset 变量名称 ], 如 unset myname 为取消myname这个变量的设置 环境变量的功能 env : 观察环境变量与常见环境变量说明 使用env命令可以列出来所有的环境变量 环境变量 HOME 代表用户的根目录 SHELL 目前这个环境使用的SHELL HISTIZE 命令历史记录的条数的最大值 MAIL 使用mail命令收信时, 系统会去读取的邮箱文件 PATH 执行文件查找的目录, 目录与目录中间以冒号( : )分隔 LANG 语系数据, 如我们中文编码通常是zh_CN.UTF-8 RANDOM 关于随机数的变量, 使用这个变量系统会主动地随机地取出一个0~32767的数值 set : 观察所有变量(含环境变量与自定义变量) 使用set命令可以列出来所有的变量 PS1: 命令提示字符的设置(PS1不是环境变量) \\d 可显示出[ 星期 月 日 ]的日期格式 \\H 完整的主机名 \\h 仅取主机名在第一个小数点之前的名字 \\t 显示时间, 为24小时格式的 [ HH:MM:SS ] \\T 显示时间, 为12小时格式的 [ HH:MM:SS ] \\A 显示时间, 为24小时格式的 [ HH:MM ] \\@ 显示时间, 为12小时格式的 [ am/pm ] \\u 目前用户的账号名称 \\v BASH的版本信息 \\w 完整的工作目录名称, 由根目录写起的目录名称, 但根目录会以~替换 \\W 利用basename函数取得工作目录名称, 所以仅会列出最后一个目录名 \\# 执行的第几个命令 \\$ 提示字符, 如果是root时, 提示字符为 #, 否则就是$ 特殊变量 特殊变量 $ 目前这个shell的进程号 ？ 上一个执行的命令所返回的值. 一般来说, 如果成功的执行某一个命令, 则会返回一个0值 export : 自定义变量转成环境变量 export 变量名称, 可以将变量转换成环境变量 直接使用export命令时, 会把所有的环境变量显示出来 locale : 影响显示结果的语系变量 locale -a : 查询Linux系统支持的语系编码 locale : 自定义语系编码 如果你设置了LANG或LC_ALL时, 但其他的语系变量没有设置, 则其他的语系变量就会被这两个变量所替换 变量的有效范围 环境变量 = 全局变量 自定义变量 = 局部变量 为什么环境变量的数据可以被子进程引用？这是因为内存配置的关系, 理论上是这样的: 当启动一个shell时, 操作系统会分配一个内存区域给shell使用, 此内存中的变量可以让子进程使用; 若在父进程利用export功能, 可以让自定义变量的内容写到上述的内存区域当中(环境变量); 当加载另一个shell时(即启动子进程, 离开原本的父进程), 子shell可以将父shell的环境变量所在的内存区域导入自己的环境变量区块当中. 变量键盘读取、数组与声明: read、array、declare read : 读取来自键盘输入的变量 (相当于输入) read [-pt] variable 选项与参数 描述 什么都不加 会主动出现一个空白行等待你的输入 -p 后面可以接提示字符 -t 后面可以接等待的秒数 declare, typeset : 声明变量的类型 declare或typeset是一样的功能 declare [-aixr] variable 变量类型默认为字符串 bash环境中的数值运算, 默认最多仅能到达整数形态, 所以1/3结果为0 数组变量类型 数组的设置方式是: variable[index]=content declare -a var var[1]=\"1\" var[2]=\"This is 2\" var[3]=\"3\" 选项与参数 描述 -a 将后面名为variable的变量定义为数组类型 -i 将后面名为variable的变量定义为整数类型 -x 用于与export一样, 就是将后面的variable变成环境变量 -r 将变量设置为readonly类型, 该变了不可被更改内容, 也不能unset. 只能通过注销再登录的方式恢复该变量的类型. 与文件系统与程序的限制关系: ulimit bash是可以限制用户的某些系统资源的, 包括可以开启的文件数量, 可以使用的CPU时间, 可以使用的内存总量等 ulimit [-SHacdfltu] [配额] 选项与参数 描述 -H hard limit, 严格的设置, 必定不能超过这个设置的数值 -S soft limit, 警告的设置, 可以超过这个设置值, 但是若超过则有警告信息在设置上, 通常soft会比hard小 -a 后面不接任何选项与参数, 可列出所有的限制额度 -c 限制每个内核文件的最大容量当某写程序发生错误时, 系统可能会将该程序在内存中的信息写成文件(除错用), 这种文件就被称为内核文件. -f 此shell可以建立的最大文件容量(一般可能设置为2GB)单位为Kbytes -d 程序可使用的最大段内存容量 -l 可用于锁定的内存量 -t 可使用的最大CPU时间 -u 单一使用者可以使用的最大进程数量 变量内容的删除、取代与替换 变量内容的删除与替换 变量设置方式 说明 ${变量#关键词}${变量##关键词} 若变量内容从头开始的数据符合 [ 关键词 ] , 则将符合的最短数据删除若变量内容从头开始的数据符合 [ 关键词 ] , 则将符合的最长数据删除 ${变量%关键词}${变量%%关键词} 若变量内容从尾向前的数据符合 [ 关键词 ] , 则将符合的最短数据删除若变量内容从尾向前的数据符合 [ 关键词 ] , 则将符合的最长数据删除 ${变量/旧字符串/新字符串}${变量//旧字符串/新字符串} 若变量内容符号 [ 旧字符串 ] 则 [ 第一个旧字符串会被新字符串替换 ]若变量内容符号 [ 旧字符串 ] 则 [ 全部的旧字符串会被新字符串替换 ] 变量的测试与内容替换 变量设置方式 str没有设置 str为空字符串 str已设置非为空字符串 var=${str-expr} var=expr var= var=$str var=${str:-expr} var=expr var=expr var=$str var=${str+expr} var= var=expr var=expr var=${str:+expr} var= var= var=expr var=${str=expr} str=exprvar=expr str不变var= str不变var=$str var=${str:=expr} str=exprvar=expr str=exprvar=expr str不变var=$str var=${str?expr} expr输出至 stderr(标准错误) var= var=$str var=${str:?expr} expr输出至 stderr(标准错误) expr输出至 stderr(标准错误) var=$str Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 22:19:20 "},"BASH/3. 命令别名与历史命令.html":{"url":"BASH/3. 命令别名与历史命令.html","title":"命令别名与历史命令","keywords":"","body":"命令别名与历史命令 命令别名设置: alias、unalias alias和unalias命令的用法 命令 说明 alias 查看目前有哪些命令别名 alias 别名='命令 选项' 设置命令别名如: alias rm='rm -i' unalias 别名 删除别名如: unalias rm 历史命令: history history命令的用法 命令 说明 history 列出目前内存内所有的history记录 history n(数字) 列出最近的n条命令记录 history -c 将目前的shell中的所有history内容全部清除 history [-raw] histfiles -r: 将histfiles的内容督导目前这个shell的history记录中-a: 将目前新增的history命令新增入histfiles中, 若没有加histfiles, 则默认写入~/.bash_histor-w: 将目前的history记录内容写入histfiles中 历史命令会在注销时, 将最近的HISTFILESIZE(环境变量)条记录记录到我的记录文件(~/.bash_history)当中. ! : 执行命令的用法(配合history使用) 命令 说明 !number 执行第几条命令如:!66 !command 由最近的命令向前查找 [ 命令串开头为command ] 的那个命令, 并执行.如: !al !! 执行上一条命令(相当于按向上键后, 回车) Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-19 13:57:41 "},"BASH/4. Bash shell的操作环境.html":{"url":"BASH/4. Bash shell的操作环境.html","title":"Bash shell的操作环境","keywords":"","body":"Bash shell的操作环境 路径与命令查找顺序 命令运行的顺序, 基本上可以这样看: 以相对/绝对路径执行命令, 例如 [ /bin/ls ] 或 [ ./ls ]; 由alias找到该命令来执行; 由bash内置的命令来执行; 通过$PATH这个变量的顺序查找到的第一个命令来执行. 使用type -a 命令也可以了解到命令查找的熟悉, 如type -a ls. bash登录与欢迎信息: /etc/issue、/etc/motd 登录画面( 在终端界面登录的时候显示的提示字符串 ) 记录在 /etc/issue 里面 issue内的代码意义 \\d 本地端时间的日期 \\l 显示第几个终端界面 \\m 显示硬件的等级(i386/i486/i586/i686...) \\n 显示主机的网络名称 \\O 显示 domain name \\r 操作系统的版本(相当于 uname -r) \\t 显示本地端时间的时间 \\S 操作系统的名称 \\v 操作系统的版本 当使用telnet这个远程登录程序连接到主机时, 主机的登陆画面就会显示 /etc/issue.net 而不是 /etc/issue . 如果想要让用户登录后取得一些信息, 例如: 想要让大家都知道的信息. 那么可以将这些加入 /etc/motd 里面. bash的环境配置文件 login 与 non-login shell login shell: 取得bash时需要完整的登录流程, 就称为login shell. login shell一般只会读取这两个配置文件: /etc/profile: 这是系统整体的设置, 最好不要修改这个文件; ~/.bash_profile 或 ~/.bash_login 或 ~/.profile: 属于用户个人设置, 你要添加自己的数据, 就写入这里. non-login shell: 取得bash的方法不需要重复登录的操作, 就称为non-login shell. /etc/profile ( login shell才会读 ) login shell情况下所读取的整体环境配置文件其实只有/etc/profile 该文件设置的主要变量 说明 PATH 会根据UID决定PATH变量要不要含有sbin的系统命令目录 MAIL 根据账号设置好用户的mailbox到 /var/spool/mail/账号名 USER 根据用户的账号设置此变量内容 HOSTNAME 根据主机的hostname命令决定此变量内容 HISTSIZE 历史命令记录条数, CentOS 7.x 设置为1000 umask 包括root默认为022, 而一般用户为002等 ~/.bash_profile ( login shell 才会读 ) 在login shell的bash环境下, 所读取的个人偏好配置文件其实主要有三个, 依序分别是: ~/.bash_profile ~/.bash_login ~/.profile login shell 设置只会读取上面三个文件的其中一个, 而读取的顺序则是按照上面的顺序. ~/.bashrc ( non-login shell会读 ) 当你取得non-login shell 时, 该bash配置文件仅会读取~./bashrc 而已. ~/.bashrc还会调用 /etc/bashrc, 因为 etc/bashrc 帮我们的bash定义出下面的内容: 根据不同的UID设置umask的值 根据不同的UID设置提示字符(就是PS1变量) 调用 /etc/profile.d/*.sh的设置 其他相关配置文件 /etc/man_db.conf 规范了使用man的时候, man page的路径到哪里去寻找 ~/.bash_history 默认的情况下, 我们的历史命令就记录在这里 ~/.bash_logout 这个文件则记录了 [ 当我注销 bash 后, 系统再帮我做完什么操作后才离开 ] 终端的环境设置: stty、set stty ( setting tyy终端的意思 ) 查看目前的一些按键内容, 可以利用stty, stty也可以帮主设置终端的输入按键代表的意义. stty [ -a ] 选项与参数 说明 -a 将目前所有的stty参数列出来, 即可以列出目前环境所有的按键列表. 按键列表几个重要关键词: 关键词 意义 ^ 表示 [ Ctrl ] 这个按键的意思 intr 发送一个 interrupt( 中断 ) 的信号给目前正在run的程序( 就是终止 ). quit 发送一个quit的信号给目前正在run的程序 erase 向后删除字符 kill 删除在目前命令行上的所有文字 eof End of file的意思, 代表 [ 结束输入 ] start 在某个程序停止后, 重新启动它的output stop 停止目前屏幕的输出 susp 送出一个 terminal stop 的信号给正在运行的程序 设置终端输入按键代表的意义: 如: stty erase ^h set 可以利用set来设置自己的一些终端设置值 set [ -uvCHhmBx ] 选项与参数 说明 -u 默认不启用, 若启用后, 当使用未设置变量时, 会显示错误信息.若要取消这个参数, 输入 set +u 即可. -v 默认不启用, 若启用后, 在信息被输出前, 会先显示信息的原始内容 -x 默认不启用, 若启用后, 在命令被执行前, 会显示命令内容 ( 前面有++符号 ) -h 默认启用, 与历史命令有关 -H 默认启用, 与历史命令有关 -m 默认启用, 与任务管理有关 -B 默认启用, 与中括号 [] 的作用有关 -C 默认不启用, 若使用 > 等, 则若文件存在时, 该文件不会被覆盖 bash默认的组合键 组合按键 执行结果 Ctrl + C 终止目前的命令 Ctrl + D 输入结束( EOF ), 例如邮件结束的时候 Ctrl + M 就是回车 Ctrl + S 暂停屏幕的输出 Ctrl + Q 恢复屏幕的输出 Ctrl + U 在提示字符下, 将整列命令删除 Ctrl + Z 暂停目前的命令 通配符与特殊符号 常用的通配符 通配符 意义 * 代表 [ 0个到无穷多个 ] 任意字符 ? 代表 [ 一定有一个 ] 任意字符 [ ] 代表 [ 一定有一个在括号内 ] 的字符( 非任意字符 ).例如: [abcd] 代表 [ 一定有一个字符, 可能是a、b、c、d中的任意一个 ]. [ - ] 若有减号( - )在中括号内, 代表 [ 在编码顺序内的所有字符 ] .例如: [0-9] 代表0和9之间的所有数字, 因为数字的语系编码是连续的. [^ ] 若中括号内的第一个字符为指数符号( ^ ) , 那表示 [ 反向选择 ].例如: [^abc] 代表一定有一个字符, 只要是非a、b、c的其他字符就接受的意思. 特殊符号 特殊符号 意义 # 注释符号: 这个最常被使用在脚本当中, 视为说明, 在其后面的数据均不执行. \\ 转义符: 将 [ 特殊字符或通配符 ] 还原成一般字符 丨 管道( pipe ): 分隔两个管道命令的符号 ; 连续命令执行分隔符: 连续性命令的界定( 注意: 与管道命令并不相同 ) ~ 用户的家目录 $ 使用变量前导符: 亦即是变量之前需要加的变量替换值 & 任务管理: 将命令变成后台任务 ! 逻辑运算意义上的 [ 非 ] not 的意思 / 目录符号: 路径分隔的符号 >、>> 数据流重定向: 输出定向, 分别是[ 替换 ] 与 [ 累加 ] 数据流重定向: 输入定向 ' ' 单引号, 不具有变量替换的功能( $变为纯文本 ) \" \" 双引号, 具有变量替换的功能( $可保留相关功能 ) ` ` 反引号, ` `中间为可以先执行的命令, 亦可使用 $( ) ( ) ( )中间为子shell的起始与结束 { } { }中间为命令区块的组合 Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-19 13:57:41 "},"BASH/5. 数据流重定向.html":{"url":"BASH/5. 数据流重定向.html","title":"数据流重定向","keywords":"","body":"数据流重定向 标准输出 ( STDOUT ) [ standard output ] 与 标准错误输出 ( STDERR ) [ standard error output ] 标准输出: 指的是命令执行所返回的正确信息 标准错误输出: 可以理解为命令执行失败后, 所返回的错误信息 数据流重定向可以将stdout与stderr分别传送到其他的文件或设备, 而分别传送所用的特殊字符则如下所示: 标准输入(stdin): 代码为0, 使用 标准输出(stdout): 代码为1, 使用 > 或 >> 标准错误输出(stderr): 代码为2, 使用 2> 或 2>> 数据流重定向 说明 将原本需要由键盘输入的数据, 改由文件内容来替换 代表 [ 结束的输入字符 ] 如: 我要用cat直接将输入的信息输出到catfile中, 且当由键盘输入eof时, 该次输入就结束. cat > catfile 1> 以覆盖的方法将 [ 正确的数据 ] 输出到指定的文件或设备上 1>> 以累加的方法将 [ 正确的数据 ] 输出到指定的文件或设备上 2> 以覆盖的方法将 [ 错误的数据 ] 输出到指定的文件或设备上 2>> 以累加的方法将 [ 错误的数据 ] 输出到指定的文件或设备上 2>&1 把标准错误输出重定向到标准输出 1>&2 把标准输出重定向到标准错误输出 &> filename 把标准输出和标准错误输出都重定向到文件filename中 命令执行的判断根据: ; 、&&、|| cmd( 不考虑命令相关性的连续命令执行 ) 在命令与命令中间利用分号 ( ; ) 来隔开, 这样一来, 分号前的命令执行完后就会立刻接着执行后面的命令. $？ ( 命令返回值 ) 与 && 与 || 若前一个命令执行的结果为正确, 在Linux下面会返回一个 $？=0 的值 命令执行情况 说明 cmd1 && cmd2 若 cmd1 执行完毕且正确执行( $?=0 ), 则开始执行 cmd2若 cmd1 执行完毕且为错误( $?≠0 ), 则 cmd2 不执行 cmd1 丨丨 cmd2 若 cmd1 执行完毕且正确执行( $?=0 ), 则 cmd2 不执行若 cmd1 执行完毕且为错误( $?≠0 ), 则开始执行 cmd2 Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-19 13:57:41 "},"BASH/6. 管道命令.html":{"url":"BASH/6. 管道命令.html","title":"管道命令","keywords":"","body":"管道命令 ( pipe ) | : 界定符号 管道命令使用的是 [ | ] 这个界定符号. [ | ] 仅能处理经由前面一个命令传来的正确信息, 也就是标准输出的信息, 但是对于标准错误并没有直接处理的能力. 在每个管道后面接的第一个数据必定是 [ 命令 ], 而且这个命令必须要能够接受标准输入的数据才行, 这样的命令才可为管道命令. 管道命令仅会处理标准输出, 对于标准错误会予以忽略. 管道命令必须要能够接受来自前一个命令的数据成为标准输入继续处理才行. 选取命令: cut、grep 选取信息通常是针对 [ 一行一行 ] 来分析的, 并不是整篇信息分析. cut cut 处理的信息时以 [ 行 ] 为单位 cut 的主要用途在于将同一行里面的数据进行分解 cut -d '分割字符' -f fields 选项与参数 说明 -d 后面接分隔字符, 与 -f 一起使用 -f 根据 -d 的分隔字符将一段信息划分成为数段, 用 -f 取出第几段的意思 -c 以字符的单位取出固定字符区间 grep grep是分析一行信息, 若当中有我们所需要的信息, 就将该行拿出来 grep [ -acinv ] [ --color=auto ] '查找字符' filename 选项与参数 说明 -a 将二进制文件以文本文件的方式查找数据 -c 计算找到 '查找字符' 的次数 -i 忽略大小写的不同, 所以大小写视为相同 -n 顺便输出行号 -v 反向选择, 亦即显示出没有 '查找字符' 内容的那一行 --color=auto 可以将找到的关键字部分加上颜色的显示, 默认的grep已经主动使用 --color=auto 选项在 alias 中了. 排序命令: sort、wc、uniq sort sort 可以帮助我们进行排序, 而且可以根据不同的数据形式来排序. sort [ -fbMnrtuk ] [ file or stdin ] 选项与参数 说明 -f 忽略大小写的差异, 例如A与a视为编码相同 -b 忽略最前面的空格字符部分 -M 以月份的名字来排序, 例如JAN、DEC等的排序方法 -n 使用 [ 纯数字 ] 进行排序 ( 默认是以文本形式来进行排序 ) -r 反向排序 -u uniq, 相同的数据中, 仅出现一行代表 -t 分隔符号, 默认使用 [ Tab ] 键来分隔 -k 以哪个区间 ( field ) 来进行排序的意思 uniq 排序完成后, 想要将重复的数据仅列出一个显示, 可以使用uniq. uniq 用来将重复的行删掉只显示一个. uniq [ -ic ] 选项与参数 说明 -i 忽略大小写字符的不同 -c 进行计数 wc wc 可以帮我们计算输出信息的整体数据 wc [ -lwm ] 选项与参数 说明 默认输出[ 行、字数、字符数 ] -l 仅列出行 -w 仅列出多少字 ( 英文字母 ) -m 多少字符 双向重定向: tee tee tee 会同时将数据流分送到文件与屏幕 tee [ -a ] file 选项与参数 说明 -a 以累加的方式, 将数据加入file当中 字符转换命令: tr、col、join、paste、expand tr tr 可以用来删除一段信息当中的文字, 或是进行文字信息的替换 tr [ -ds ] SET1 ... 选项与参数 说明 -d 删除信息当中的 SET1 这个字符 -s 替换掉重复的字符 col col 可以用来简单地处理将 [ Tab ] 按键替换成为空格键 col [ -xb ] 选项与参数 说明 -x 将 [ Tab ] 键转换成对等的空格键 join join 主要是在处理 [ 两个文件当中, 有相同数据的那一行, 才将它加在一起 ] 的意思. 注意: 在使用 join 之前, 你所需要处理的文件应该事先经过排序处理, 否则有些比对的项目会被忽略. join [ -ti12 ] file1 file2 选项与参数 说明 -t join 默认以空格字符分隔数据, 并且比对 [ 第一个栏位 ] 的数据, 如果两个文件相同, 则将两条数据连成一行, 且第一个栏位放在第一个. -i 忽略大小写的差异. -1( 数字1 ) 代表 [ 第一个文件要用哪个栏位来分析 ] 的意思. -2 代表 [ 第二个文件要用哪个栏位来分析 ] 的意思. paste paste 就是直接将两行贴在一起, 且中间以 [ Tab ] 键隔开. paste [ -d ] file1 file2 选项与参数 说明 -d 后面可以接分隔符, 默认是以 [ Tab ] 键来分离. expand expand 就是将 [ Tab ] 键转成空格键 expand [ -t ] file 选项与参数 说明 -t 后面可接数字, 一般来说一个 [ Tab ] 键可以用8个空格键替换, 我们也可自行定义一个 [ Tab ] 键代表多少个字符. 划分命令: split split split 可以帮你将一个大文件, 依据文件大小或行数进行划分, 即可以将大文件划分成为小文件. split [ -bl ] file PREFIX 选项与参数 说明 -b 后面可接欲划分成的文件大小, 可加单位, 例如b、k、m等 -l 以行数来进行划分 PREFIX 代表前缀字符的意思, 可作为划分文件的前缀文字 参数代换: xargs xargs xargs 就是在产生某个命令的参数的意思 xargs 可以读入 stdin 的数据, 并且以空格符或换行符作为标识符, 将stdin的数据分隔成为参数 要使用 xargs 的原因是, 很多命令其实并不支持管道命令, 因此我们可以通过 xargs 来提供该命令使用的 标准输入. xargs [ -0epn ] command 当 xargs 后面没有接任何命令时, 默认以 echo 来进行输出. 选项与参数 说明 -0(数字0) 如果输入的 stdin 含有特殊字符, 例如 ` 、 \\ 、空格等字符时, 这个 -0 参数可以将它还原成一般字符, 这个参数可以用于特殊状态. -e 这是 EOF ( End of file ) 的意思, 后面可以接一个字符, 当 xargs 分析到这个字符时, 就会停止工作 -p 在执行每个命令时, 都会询问使用者的意思 -n 后面接次数, 每次 command 命令执行时, 要使用几个参数的意思 关于减号 [ - ] 的用途 在管道命令当中, 常常会用到前一个命令的 stdout 作为这次的 stdin, 某些命令需要用到文件名来处理时, 该 stdin 与 stdout 可以利用减号 \" - \" 来替代. 例如: tar -cvf - /home | tar -xvf - -C /tmp/homeback Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-26 17:29:23 "},"正则表达式与文件格式化处理/":{"url":"正则表达式与文件格式化处理/","title":"正则表达式与文件格式化处理","keywords":"","body":"Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 16:18:35 "},"正则表达式与文件格式化处理/1. 什么是正则表达式.html":{"url":"正则表达式与文件格式化处理/1. 什么是正则表达式.html","title":"什么是正则表达式","keywords":"","body":"什么是正则表达式？ 正则表达式 正则表达式就是处理字符串的方法, 它以行为单位来进行字符串的处理操作, 正则表达式通过一些特殊符号的辅助, 可以让用户轻易地完成 [ 查找、删除、替换] 某特定字符串的处理过程. 正则表达式基本上是一种 [ 表示法 ] , 只要程序支持这种表示法, 那么该程序就可以用来作为正则表达式的字符串处理只用. 如: cp、ls等命令并未支持正则表达式, 所以就只能使用 bash 自己本身的通配符而已. 正则表达式的字符串表示方式按照不同的严谨度而分为: 基础表达式 扩展正则表达式 正则表达式与通配符是完全不一样的东西 通配符: 代表的是 bash 操作接口的一个功能 正则表达式: 是一种字符串处理的表示方式 Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-28 15:28:03 "},"正则表达式与文件格式化处理/2. 基础正则表达式.html":{"url":"正则表达式与文件格式化处理/2. 基础正则表达式.html","title":"基础正则表达式","keywords":"","body":"基础正则表达式 语系对正则表达式的影响 使用正则表达式时, 需要特别留意当时环境的语系是什么, 否则可能会发现与别人不相同的选取结果. LANG=C 时: 0 1 2 3 4 ... A B C D ... Z a b c d ... z LANG=zh_CN 时: 0 1 2 3 4 ... a A b B c C d D ... z Z 特殊符号 特殊符号 ( 中括号也是特殊符号的一部分 ) 代表意义 [:alnum:] 代表英文大小写字符及数字, 亦即 0~9、A~Z、a~z [:alpha:] 代表任何英文大小写字符, 亦即 A~Z、a~z [:blank:] 代表空格键与 [Tab] 按键两者 [:cntrl:] 代表键盘上面的控制按键, 包括 CR、LF、Tab、Del等 [:digit:] 代表数字, 即 0~9 [:graph:] 除了空格符 ( 空格键与 [Tab] 按键 ) 外的其他所有按键 [:lower:] 代表小写字符, 即 a~z [:print:] 代表任何可以被打印出来的字符 [:punct:] 代表标点符号, 亦即: \"、'、？、!、;、:、#、$ [:upper:] 代表大写字符, 即 A~Z [:space:] 任何会产生空白的字符, 包括空格键、[Tab]、CR 等 [:xdigit:] 代表十六进制的数字类型, 因此包括 0~9、A~F、a~f 的数字与字符 grep 的一些高级选项 grep 最重要的功能就是进行字符串数据的比对, 然后将符合用户需求的字符串打印出来. grep 在数据中查寻一个字符串时, 是以 [整行] 为单位来进行数据的获取. 也就是说, 假如一个文件内有 10 行, 其中有两行具有你所查找的字符串, 则将两行显示在屏幕上, 其他的就丢弃. grep [-A] [-B] [--color=auto] '查找字符' filename 选项与参数 说明 -A 后面可加数字, 为 after 的意思, 除了列出该行外, 后续的n行也列出来 -B 后面可加数字, 为 before 的意思, 除了列出该行外, 前面的n行也列出来 --color=auto 可将正确的那个选取数据列出颜色 基础正则表达式字符集合 RE字符 意义与范例 ^word 意义: 待查找的字符串 ( word ) 在行首范例: 查找regular_express.txt文件中行首为 # 开始的那一行, 并列出行号grep -n '^#' regular_express.txt work$ 意义: 待查找的字符串 ( word ) 在行尾范例: 将regular_express.txt文件中行尾为 ! 那一行打印出来grep '!$' regular_express.txt . 意义: 代表 [ 一定有一个任意字符 ] 的字符范例: 查找的字符串可以是 ( eve )、( eae )、( eee )、( e e ), 但不能仅有( ee ), 亦即e与e中间 [一定] 仅有一个字符, 而空格符也是字符grep -n 'e.e' regular_express.txt \\ 意义: 转义符, 将特殊符号的特殊意义去除范例: 查找含有单引号 ( ' ) 的那一行grep -n \\' regular_express.txt * 意义: 重复0个到无穷多个的前一个RE字符范例: 找出含有 ( es )、( ess )、( esss ) 等的字符串, 注意, 因为 可以使0个, 所以 es 也是符合待查找字符串. 另外, 因为 为重复 [ 前一个RE字符 ] 的符号, 因此, 在 之前必须要紧接着一个RE字符. 例如任意字符则为 [ . ].grep -n 'ess*' regular_express.txt [list] 意义: 字符集合的RE字符, 里面列出想要选取的字符范例: 查找含有 ( gl ) 或 ( gd ) 的那一行, 需要特别留意的是, 在 [] 当中 [ 谨代表一个待查找的字符 ], 例如 [ a[afl]y ] 代表查找的字符串可以使aay、afy、aly即 [afl] 代表a或f或l的意思.grep -n 'g[ld]' regular_express.txt [n1-n2] 意义: 字符集合的RE字符, 里面列出想要选取的字符范围.范例: 查找含有任意数字的那一行. 需特别留意, 在这个字符集合 [] 中的减号 - 是有特殊意义的, 它代表两个字符之间的所有连续字符. 但这个连续与否与ASCII编码有关, 因此, 你的编码需要设置正确.grep -n '[0-9]' regular_express.txt [^list] 意义: 字符集合的RE字符, 里面列出不要的字符串范围范例: 查找的字符串可以使 ( oog )、( ood ) 但不能是 ( oot ), 那个 ^ 在 [] 内时, 代表的意义是 [ 反向选择 ] 的意思.grep -n 'oo[\\^t]' regular_express.txt \\{n,m\\} 意义: 连续 n 到 m 个的 [ 前一个RE字符 ]意义: 若为 \\{n\\} 则是连续n个的前一个RE字符意义: 若为\\{n,\\} 则是连续n个以上的前一个RE字符特别注意的, {} 在bash中有特殊意义, 必须要转义范例: 在 g 与 g 之间有2个到3个的o存在的字符串, 亦即 ( goog )、( gooog ).grep -n 'go\\{2,3\\}g' regular_express.txt 正则表达式的特殊字符与一般命令行输入命令的通配符并不相同 特别注意的: ^ : 在 [] 外代表定位在行首, 在 [] 内代表反向选择 $ : 在行尾 ^$ : 只有行首跟行尾, 可以用此找出空白行 . ( 小数点 ) : 代表一定有一个任意字符的意思 * ( 星星号 ) : 代表重复前一个字符, 0到无穷多次的意思 .* : 代表领个或多个任意字符 \\{\\} ( 限定范围符号 ) : 因为 {} 在shell是有特殊意义的, 因此使用时必须使用转义符\\来让它失去特殊意义才行. sed 工具 sed 本身也是一个管道命令, 可以分析标准输入. sed 还可以将数据进行替换、删除、新增、选取特定行等功能. sed [ -nefr ] [ 操作 ] sed 后面接的操作务必以 \" 两个单引号括住. 选项与参数 说明 -n 使用安静模式, 在一般sed的用法中, 所有来自 stdin 的数据一般都会被列出到屏幕上. 但如果加入 -n 参数后, 则只有经过sed特殊处理的那一行( 或操作 ) 才会被列出来. -e 直接在命令行模式上进行sed的操作编辑. -f 直接将sed的操作写在一个文件内, -f filename 则可以执行 filename 内的 sed 操作. -r sed 的操作使用的是扩展型正则表达式的语法. ( 默认是基础正则表达式语法 ) -i 直接修改读取的文件内容, 而不是由屏幕输出. 操作说明: [n1[,n2]] function n1, n2 不见得会存在, 一般代表 [ 选择进行操作的行数 ].举例来说, 如果我的操作时需要在10到20行之间进行的, 则 [ 10,20[操作行为] ].( $ 代表最后一行 ) function 如下: a 新增, a的后面可以接字符, 而这些字符会在新的一行出现( 目前的下一行 ) c 替换, c的后面可以接字符, 这些字符可以替换n1,n2之间的行 d 删除, 因为是删除, 所以d后面不接如何东西 i 插入, i的后面可以接字符, 而这些字符会在新的一行出现( 目前的上一行 )多行新增, 每一行之间都必须要以反斜杠( \\ ) 来进行新行的增加. p 打印, 亦即将某个选择的数据打印出来. 通常 p 会与参数 sed -n 一起运行 s 替换, 可以直接进行替换的工作, 通常这个 s 的操作可以搭配正则表达式, 例如 1,20s/old/new/g就是.sed 's/要被替换的字符/新的字符/g' Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 16:35:22 "},"正则表达式与文件格式化处理/3. 扩展正则表达式.html":{"url":"正则表达式与文件格式化处理/3. 扩展正则表达式.html","title":"扩展正则表达式","keywords":"","body":"扩展正则表达式 群组功能 : | 在单引号内的管道 ( | ) 意义为 [ 或 or ] 如: grep -v '^$' text.txt | grep -v '^#' 可以简化为: egrep -v '^$|^#' text.txt grep 默认仅支持正则表达式, 如果要使用扩展正则表达式可以使用 grep -E 建议直接使用 egrep egrep 与 grep -E 是类似于命令别名的关系 扩展正则表达式 RE字符 意义与范例 + 意义: 重复 [ 一个或一个以上 ] 的前一个RE字符范例: 查找god、good、good等的字符串. 那个 o+ 代表 [ 一个以上的o ].egrep -n 'go+d' regular_express.txt ? 意义: [ 零个或一个 ] 的前一个RE字符范例: 查找gd、god这两个字符串. 那个 o? 代表 [ 空的或1个o ]egrep -n 'go?d' regular_express.txt 丨 意义: 用或 ( or ) 的方式找出数个字符串范例: 查找gd或good或dog这两个字符串egrep -n 'gd丨good丨dog' regular_express.txt () 意义: 找出 [ 群组 ] 字符串范例: 查找glad或good这两个字符串, 因为g与d是重复的, 所以, 我们就可以将la与oo列于 ( ) 当中, 并以 丨 分隔开来.egrep -n 'g(la丨oo)d' regular_express.txt () + 意义: 多个重复群组的判别范例: 将 [ AxyzxyzxyzxyzC ] 用echo打出, 然后再使用如下的方法查找一下.echo 'AxyzxyzxyzC' 丨 egrep 'A(xyz)+C' ! 在正则表达式当中并不是特殊字符, 如果你想要查出来文件中含有!与>的字行时, 可以这样: grep -n '[!>]' regular_express.txt 反向选择是[^], 而不是!. Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 16:32:39 "},"正则表达式与文件格式化处理/4. 文件的格式化与相关处理.html":{"url":"正则表达式与文件格式化处理/4. 文件的格式化与相关处理.html","title":"文件的格式化与相关处理","keywords":"","body":"文件的格式化与相关处理 格式化打印: printf printf '打印格式' 实际内容 printf 不是管道命令 选项与参数 说明 \\a 警告声音输出 \\b 退格键 \\f 清楚屏幕 \\n 输出新的一行 \\r 回车 \\t 水平的 [ Tab ] 按键 \\v 垂直的 [ Tab ] 按键 \\xNN NN为两位数的数字, 可以转换数字成为字符 C语言程序内, 常见的变量格式 变量格式 说明 %ns n是数字, s 代表 string, 亦即多少个字符 %ni n是数字, i 代表 integer, 亦即多少整数位数 %N.nf n与N都是数字, f 代表 floating ( 浮点 ).如果有小数位数, 如共要十个位数, 但小数点有两位, 即为%10.2f awk : 好用的数据处理工具 sed 常常作用于一整个行的处理, awk 则比较倾向于一行当中分成数个字段来处理. awk 相当适合处理小型的文本数据 awk '条件类型1{操作1} 条件类型2{操作2} ...' filename awk 后面接两个单引号并加上大括号来设置想要对数据进行的处理操作 awk 主要处理每一行的字段内的数据, 而默认的字段的分隔符为\"空格键\"或\"[ Tab ]键\" 使用 awk 的时候, 请先确认一下数据, 如果是连续性的数据, 请不要有空格或 [ Tab ] 在内, 否则, 会产生误判. 在 awk 的括号内, 每一行的每个字段都是有变量名称的, 那就是 $1, $2 等变量名称. $1 就是第一栏, $2 就是第二栏, 以此类推. $0 代表 [ 一整列数据 ] 的意思. awk 的处理流程 读入第 1 行, 并将第 1 行的数据写入$0、$1、$2等变量当中. 根据 \"条件类型\" 的限制, 判断是否需要进行后面的 \"操作\". 完成所有操作与条件类型. 若还有后续的 [ 行 ] 的数据, 则重复上面 1~3 的步骤, 直到所有的数据都读完为止. awk 是以行为一次处理的单位, 而以字段为最小的处理单位. awk的内置变量 注意: 在awk内的NR、NF等变量要用大写, 且不需要美元符号$. 内置变量 意义 NF 每一行 ( $0 ) 拥有的字段数 NR 目前 awk 所处理的是第几行数据 FS 目前的分隔字符, 默认是空格键 awk 的逻辑运算字符 运算单元 意义 > 大于 小于 >= 大于或等于 小于或等于 == 等于 != 不等于 在awk中使用 print 功能可以格式化输出 取出账号与登陆者的IP, 且账号与IP之间以 [ Tab ] 隔开. last -n 5 |awk '{print $1 \"\\t\" $3}' 在awk中使用 BEGIN 关键词, 可以预先设置 awk 的变量 读入第一行的时候, 第一行的数据还是以默认格式读入到变量中. 在 /etc/passwd 当中是以 \":\" 来作为分隔字符, 我要查看, 第三栏小于10以下的数据, 并且列出账号与第三列 cat /etc/passwd | awk 'BEGIN {FS=\":\"} $3 awk 的命令间隔: 所有 awk 的操作, 亦即在{}内的操作, 如果有需要多个命令辅助时, 可利用分号 ( ; ) 间隔, 或直接以 [ Enter ] 按键来隔开每个命令. 文件比对工具 通常用在 ASCII 纯文本文件比对的命令中, 最常见的就是: diff 比对非纯文本文件, 可以使用: cmp diff diff 就是用在比对两个文件之间的差异, 并且是以行为单位来比对, 一般是用在 ASCII 纯文本文件的比对上. diff通常使用在同一个文件( 或软件 )的新旧版本差异上. diff [-bBi] from-file to-file 选项与参数 说明 from-file 一个文件名, 作为原始比对文件的文件名.可以用 [ - ] 替换, [ - ] 代表 [ 标准输入 ] 之意. to-file 一个文件名, 作为目标比对文件的文件名.可以用 [ - ] 替换, [ - ] 代表 [ 标准输入 ] 之意. -b 忽略一行当中, 仅有多个空白的差异. -B 忽略空白行的差异. -i 忽略大小写的不同. cmp cmp 主要比对两个文件, 它主要利用字节单位去比对, 因此, 可以比对二进制文件. cmp [-l] file1 file2 选项与参数 说明 -l 将所有不同点的字节处都列出来, 因为 cmp 默认仅会输出第一个发现的不同点. patch : 处理补丁功能 patch 命令可以将旧版数据更新到新版 ( 主要亦由 diff 建立 patch 的补丁源文件) patch 就是将旧的文件升级成新的文件 先比较旧版本的差异 将差异文件制作成为补丁文件 由补丁文件更新旧文件 制作补丁文件 diff -Naur passwd.old passwd.new > passwd.patch 更新: patch -pN 还原: patch -R -pN 选项与参数 说明 -p 后面可以接 [ 取消几层目录 ] 的意思 -R 代表还原, 将新的文件还原成原来旧的版本 文件打印设置: pr Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 16:34:18 "},"学习shell脚本/":{"url":"学习shell脚本/","title":"学习shell脚本","keywords":"","body":"Copyright © voidck.com all right reserved，powered by Gitbook该文件修订时间： 2020-06-29 21:25:26 "}}